---
phase: 08-dashboard-shell-and-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - tools/gsd-review-broker/src/gsd_review_broker/dashboard.py
  - tools/gsd-review-broker/src/gsd_review_broker/server.py
  - tools/gsd-review-broker/tests/test_dashboard.py
autonomous: true
requirements:
  - DASH-01

must_haves:
  truths:
    - "GET /dashboard returns the built index.html with 200 status"
    - "GET /dashboard/assets/{file} returns static assets (CSS, JS) with correct content types"
    - "GET /dashboard/events returns an SSE stream (text/event-stream content type)"
    - "Dashboard module is imported and registered in server.py startup"
    - "All dashboard routes are testable with HTTPX/Starlette TestClient"
  artifacts:
    - path: "tools/gsd-review-broker/src/gsd_review_broker/dashboard.py"
      provides: "HTTP route handlers for static file serving and SSE endpoint"
      exports: ["register_dashboard_routes"]
      min_lines: 60
    - path: "tools/gsd-review-broker/tests/test_dashboard.py"
      provides: "Tests for dashboard route handlers"
      min_lines: 40
  key_links:
    - from: "tools/gsd-review-broker/src/gsd_review_broker/server.py"
      to: "tools/gsd-review-broker/src/gsd_review_broker/dashboard.py"
      via: "import and call register_dashboard_routes(mcp)"
      pattern: "register_dashboard_routes"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/dashboard.py"
      to: "tools/gsd-review-broker/dashboard/dist/"
      via: "Path resolution to static files directory"
      pattern: "dist"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/dashboard.py"
      to: "/dashboard/events"
      via: "SSE endpoint route registration"
      pattern: "dashboard/events"
---

<objective>
Create the Python dashboard module that serves the Astro-built static files from the broker process and provides the SSE endpoint for real-time data push. Wire the module into server.py and create comprehensive tests.

Purpose: Make the dashboard accessible at `http://127.0.0.1:8321/dashboard` by having the running broker serve the pre-built static files directly. The SSE endpoint enables future tabs to receive live data.
Output: Working dashboard route serving static files + SSE endpoint, with tests passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-dashboard-shell-and-infrastructure/08-CONTEXT.md
@.planning/phases/08-dashboard-shell-and-infrastructure/08-01-SUMMARY.md
@tools/gsd-review-broker/src/gsd_review_broker/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard.py module with static file serving and SSE endpoint</name>
  <files>
    tools/gsd-review-broker/src/gsd_review_broker/dashboard.py
    tools/gsd-review-broker/src/gsd_review_broker/server.py
  </files>
  <action>
Create `tools/gsd-review-broker/src/gsd_review_broker/dashboard.py` with a `register_dashboard_routes(mcp)` function that registers all dashboard HTTP routes using `mcp.custom_route()`.

**IMPORTANT route ordering:** FastMCP registers custom routes in the order they are defined. The catch-all `{path:path}` route MUST be registered LAST, otherwise it will intercept `/dashboard/events` and other specific routes. Register routes in this order:
1. `/dashboard/events` (SSE endpoint) -- FIRST
2. `/dashboard` (index.html) -- SECOND
3. `/dashboard/{path:path}` (static asset catch-all) -- LAST

**Route: GET /dashboard** (index page):
- Resolve the `dist/` directory path relative to the dashboard.py module file: `Path(__file__).resolve().parent.parent.parent / "dashboard" / "dist"` (from src/gsd_review_broker/ up to tools/gsd-review-broker/, then into dashboard/dist/)
- Read and return `dist/index.html` as `HTMLResponse`
- If `dist/index.html` does not exist, return a `PlainTextResponse("Dashboard not built. Run 'npm run build' in dashboard/", status_code=503)`
- Import from starlette: `from starlette.responses import HTMLResponse, PlainTextResponse, Response, StreamingResponse`
- Import from starlette: `from starlette.requests import Request`

**Route: GET /dashboard/{path:path}** (static assets):
- Serve files from `dist/` directory based on the path parameter
- Resolve the full file path: `dist_dir / path`
- Security: Verify the resolved path is within `dist_dir` using `.resolve()` and checking it starts with the dist_dir resolved path (prevent path traversal)
- If file does not exist, return 404 `PlainTextResponse("Not found", status_code=404)`
- Determine content type from file extension: `.html` -> `text/html`, `.css` -> `text/css`, `.js` -> `application/javascript`, `.svg` -> `image/svg+xml`, `.json` -> `application/json`, `.ico` -> `image/x-icon`. Default to `application/octet-stream`.
- Return `Response(content=file_bytes, media_type=content_type)`
- Use synchronous file reads (static assets are small, no need for async file I/O)

**Route: GET /dashboard/events** (SSE endpoint):
- Return a `StreamingResponse` with `media_type="text/event-stream"` and headers `Cache-Control: no-cache`, `Connection: keep-alive`, `X-Accel-Buffering: no`
- Create an async generator that:
  1. Sends an initial `event: connected\ndata: {"status": "connected"}\n\n` message
  2. Then sends a heartbeat `event: heartbeat\ndata: {}\n\n` every 15 seconds to keep the connection alive
  3. Future phases will add real data events (overview stats, log entries, review updates)
  4. Use `asyncio.sleep(15)` for the heartbeat interval
  5. Wrap in try/except for `asyncio.CancelledError` (client disconnect) -- just return cleanly
- Access the lifespan context via `request.app.state` if needed for future data queries, but for now the SSE endpoint only sends heartbeats
- Log SSE connections at INFO level: `logger.info("Dashboard SSE client connected")` and disconnections

**Wire into server.py:**
- Add import AFTER the tools import (same pattern): `from gsd_review_broker.dashboard import register_dashboard_routes  # noqa: E402`
- Call `register_dashboard_routes(mcp)` after the import
- This follows the existing side-effect import pattern used for tools

**Module-level constants:**
- `DIST_DIR: Path` -- resolved once at module load time
- `CONTENT_TYPES: dict[str, str]` -- extension to MIME type mapping
- `SSE_HEARTBEAT_INTERVAL: int = 15` -- seconds between heartbeats
  </action>
  <verify>
- File exists: `tools/gsd-review-broker/src/gsd_review_broker/dashboard.py`
- Grep for `register_dashboard_routes` in both dashboard.py and server.py
- Python syntax check: `python -c "from gsd_review_broker.dashboard import register_dashboard_routes"` from the src directory (or use `uv run python -c "..."` from broker root)
  </verify>
  <done>Dashboard module created with three routes (index, static assets, SSE) and wired into server.py. Module imports cleanly without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create dashboard route tests</name>
  <files>
    tools/gsd-review-broker/tests/test_dashboard.py
  </files>
  <action>
Create `tools/gsd-review-broker/tests/test_dashboard.py` with tests for all dashboard routes.

**Test approach:** Use Starlette's `TestClient` (from `starlette.testclient`) or httpx `ASGITransport` to test the HTTP routes directly. Since FastMCP's `http_app()` returns a Starlette app, we can create a test client against it.

**Test fixture:**
- Create a pytest fixture that builds a test Starlette app from the mcp instance
- Use `from gsd_review_broker.server import mcp` and call `mcp.http_app(transport="streamable-http", stateless_http=True)` to get the testable app
- Use `httpx.AsyncClient` with `httpx.ASGITransport(app=app)` for async testing (consistent with pytest-asyncio auto mode)
- Alternative: if httpx is not available, use `starlette.testclient.TestClient` (sync) -- check which is available in deps first

**Since the broker tests use pytest-asyncio auto mode and httpx may not be a direct dependency, check if starlette.testclient is available (it should be, transitively through FastMCP).** Use `from starlette.testclient import TestClient` with sync tests if httpx async is not available. The TestClient from starlette uses httpx under the hood synchronously.

**Test: test_dashboard_index_returns_html:**
- GET `/dashboard` should return 200 with HTML content
- Response should contain "GSD Tandem" in the body
- Content-Type should be text/html

**Test: test_dashboard_index_not_built:**
- Temporarily make the dist directory path point to a non-existent location
- GET `/dashboard` should return 503
- Use monkeypatch or mock the DIST_DIR constant in dashboard module

**Test: test_dashboard_static_asset_css:**
- GET `/dashboard/_astro/{some-css-file}` should return 200 with text/css content type
- Use a known file from the built dist/ (or create a temporary dist structure for testing)

**Test: test_dashboard_static_asset_js:**
- GET `/dashboard/_astro/{some-js-file}` should return 200 with application/javascript content type

**Test: test_dashboard_static_asset_not_found:**
- GET `/dashboard/nonexistent-file.xyz` should return 404

**Test: test_dashboard_path_traversal_blocked:**
- GET `/dashboard/../pyproject.toml` should return 404 (not serve files outside dist/)
- GET `/dashboard/../../etc/passwd` should return 404

**Test: test_dashboard_sse_endpoint:**
- GET `/dashboard/events` with appropriate headers
- Should return text/event-stream content type
- Should receive the initial "connected" event
- Close connection after receiving the first event (don't wait for heartbeats in test)

**Test: test_dashboard_sse_heartbeat:**
- Connect to SSE endpoint, wait for both the connected event and at least one heartbeat
- Use a shorter heartbeat interval for testing if possible (or mock asyncio.sleep)
- Alternative: test with a timeout -- if heartbeat arrives within reasonable time, pass

**IMPORTANT:** The tests should work with the actual built `dist/` directory from Plan 01. If the dist/ doesn't exist (CI environment), tests that depend on static files should be skipped with `pytest.mark.skipif`.

Run: `uv run pytest tests/test_dashboard.py -v` from `tools/gsd-review-broker/`

Also run the full test suite to verify no regressions: `uv run pytest -v` from `tools/gsd-review-broker/`
  </action>
  <verify>
- `uv run pytest tests/test_dashboard.py -v` from `tools/gsd-review-broker/` -- all tests pass
- `uv run pytest -v` from `tools/gsd-review-broker/` -- full suite passes with no regressions
  </verify>
  <done>Dashboard route tests pass. Full test suite shows no regressions. Tests cover: index page serving, static asset serving with correct content types, 404 for missing files, path traversal prevention, SSE endpoint connection and heartbeat.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_dashboard.py -v` passes all tests
- `uv run pytest -v` passes full suite (no regressions from existing 145+ tests)
- `python -c "from gsd_review_broker.dashboard import register_dashboard_routes"` imports cleanly
- `grep "register_dashboard_routes" tools/gsd-review-broker/src/gsd_review_broker/server.py` finds the import
- Dashboard routes handle: index (200 HTML), assets (200 with MIME types), missing files (404), path traversal (404), SSE (text/event-stream)
</verification>

<success_criteria>
- Dashboard module registered in server.py following existing import side-effect pattern
- GET /dashboard serves the Astro-built index.html
- GET /dashboard/{path} serves static assets with correct MIME types
- GET /dashboard/events returns SSE stream with heartbeat
- Path traversal attacks return 404
- Missing dist/ returns 503 with helpful message
- All new tests pass, no regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/08-dashboard-shell-and-infrastructure/08-02-SUMMARY.md`
</output>
