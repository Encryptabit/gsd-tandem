---
phase: 03-discussion-and-patches
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - tools/gsd-review-broker/src/gsd_review_broker/tools.py
  - tools/gsd-review-broker/tests/test_counter_patch.py
autonomous: true

must_haves:
  truths:
    - "Reviewer can attach a counter-patch diff to a request_changes or comment verdict"
    - "Counter-patch is validated via git apply --check before being stored"
    - "Proposer can accept a counter-patch, replacing the active diff (re-validated on accept)"
    - "Proposer can reject a counter-patch, clearing counter-patch columns"
    - "list_reviews sorts by priority (critical first, normal, low) then by created_at"
    - "get_review_status can optionally wait for notification before returning"
  artifacts:
    - path: "tools/gsd-review-broker/src/gsd_review_broker/tools.py"
      provides: "Counter-patch in submit_verdict, accept/reject tools, priority sort, notification polling"
      contains: "accept_counter_patch"
    - path: "tools/gsd-review-broker/tests/test_counter_patch.py"
      provides: "Counter-patch lifecycle tests, priority sort tests, notification polling tests"
      min_lines: 120
  key_links:
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py (submit_verdict)"
      to: "diff_utils.validate_diff"
      via: "counter-patch validation on verdict submission"
      pattern: "validate_diff.*counter_patch"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py (accept_counter_patch)"
      to: "diff_utils.validate_diff"
      via: "re-validation on acceptance (diff may be stale)"
      pattern: "validate_diff.*counter_patch"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py (list_reviews)"
      to: "reviews table (priority column)"
      via: "ORDER BY CASE COALESCE(priority, 'normal')"
      pattern: "COALESCE.*priority"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py (get_review_status)"
      to: "notifications.py (NotificationBus)"
      via: "wait_for_change before returning status"
      pattern: "wait_for_change"
---

<objective>
Implement counter-patch submission, acceptance/rejection lifecycle, priority-based list sorting, and notification-enhanced polling.

Purpose: Completes Phase 3 by adding the reviewer's ability to supply alternative patches on verdicts, the proposer's ability to accept/reject those patches, priority-ordered review listing, and reduced-latency polling via the internal notification bus. These features enable richer reviewer feedback and better review queue management.

Output: Modified submit_verdict with counter-patch support, two new tools (accept_counter_patch, reject_counter_patch), modified list_reviews with priority sort, modified get_review_status with optional notification wait, and comprehensive tests for all new behavior.
</objective>

<execution_context>
@C:\Users\Jacar\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Jacar\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-discussion-and-patches/03-RESEARCH.md
@.planning/phases/03-discussion-and-patches/03-01-SUMMARY.md
@tools/gsd-review-broker/src/gsd_review_broker/tools.py
@tools/gsd-review-broker/src/gsd_review_broker/diff_utils.py
@tools/gsd-review-broker/src/gsd_review_broker/models.py
@tools/gsd-review-broker/src/gsd_review_broker/notifications.py
@tools/gsd-review-broker/src/gsd_review_broker/db.py
@tools/gsd-review-broker/tests/conftest.py
@tools/gsd-review-broker/tests/test_proposals.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Counter-patch in submit_verdict, accept/reject tools, priority sort, notification polling</name>
  <files>
    tools/gsd-review-broker/src/gsd_review_broker/tools.py
  </files>
  <action>
    **Modify submit_verdict** -- Add optional `counter_patch: str | None = None` parameter.
    1. After notes enforcement checks but before the comment verdict branch, add counter-patch validation:
       - If counter_patch is not None and verdict not in ("request_changes", "comment"), return {"error": "Counter-patches only allowed with request_changes or comment verdicts"} (per discretion: not allowed on approve).
       - If counter_patch is not None, validate it: `is_valid, error_detail = await validate_diff(counter_patch, cwd=app.repo_root)`. If not valid, return {"error": "Counter-patch diff validation failed", "validation_error": error_detail}.
       - Compute `counter_affected = extract_affected_files(counter_patch)`.
    2. In the comment verdict branch: if counter_patch is provided, add to the UPDATE: `counter_patch = ?, counter_patch_affected_files = ?, counter_patch_status = 'pending'`. Include counter_patch and counter_affected in the parameter tuple.
    3. In the standard verdict branch (approved/changes_requested): if counter_patch is provided and verdict is "changes_requested", add the same counter-patch columns to the UPDATE. For "approved" verdict, counter_patch would already be rejected by the check in step 1.
    4. After commit, if counter_patch was provided, fire `app.notifications.notify(review_id)`.
    5. Include `has_counter_patch: True` in the return dict when counter_patch was provided.

    **Add accept_counter_patch tool** -- New @mcp.tool:
    - Parameters: review_id (str), ctx (Context = None)
    - Inside write_lock + BEGIN IMMEDIATE:
      1. SELECT status, counter_patch, counter_patch_affected_files, counter_patch_status FROM reviews WHERE id = ?
      2. Verify review exists
      3. Verify counter_patch_status == 'pending' (if NULL or not pending, return error "No pending counter-patch to accept")
      4. Re-validate the counter-patch diff: `is_valid, error_detail = await validate_diff(row["counter_patch"], cwd=app.repo_root)`. If not valid, return {"error": "Counter-patch no longer applies cleanly", "validation_error": error_detail} -- do NOT modify review state (per research pitfall 4).
      5. UPDATE reviews SET diff = counter_patch, affected_files = counter_patch_affected_files, counter_patch = NULL, counter_patch_affected_files = NULL, counter_patch_status = 'accepted', updated_at = datetime('now') WHERE id = ?
      6. COMMIT
    - After commit: fire app.notifications.notify(review_id)
    - Return: {"review_id": review_id, "counter_patch_status": "accepted", "message": "Counter-patch accepted as active diff"}

    **Add reject_counter_patch tool** -- New @mcp.tool:
    - Parameters: review_id (str), ctx (Context = None)
    - Inside write_lock + BEGIN IMMEDIATE:
      1. SELECT counter_patch_status FROM reviews WHERE id = ?
      2. Verify review exists
      3. Verify counter_patch_status == 'pending' (else error)
      4. UPDATE reviews SET counter_patch = NULL, counter_patch_affected_files = NULL, counter_patch_status = 'rejected', updated_at = datetime('now') WHERE id = ?
      5. COMMIT
    - After commit: fire app.notifications.notify(review_id)
    - Return: {"review_id": review_id, "counter_patch_status": "rejected"}

    **Modify list_reviews** -- Update both SQL queries (with and without status filter):
    - Add `priority` to the SELECT column list
    - Add ORDER BY clause: `ORDER BY CASE COALESCE(priority, 'normal') WHEN 'critical' THEN 0 WHEN 'normal' THEN 1 WHEN 'low' THEN 2 END, created_at ASC`
    - Include `priority` in each review dict in the response

    **Modify get_review_status** -- Add optional `wait: bool = False` parameter:
    - If wait is True, before querying the DB, call `await app.notifications.wait_for_change(review_id, timeout=25.0)`. This blocks up to 25s waiting for a state change signal. Whether signaled or timed out, proceed to query and return current status.
    - If wait is False (default), behave exactly as before (immediate return). This preserves backward compatibility.
    - Add `priority` and `current_round` to the SELECT and response dict.
    - Update docstring to mention the wait parameter.

    Follow all existing patterns: dict error returns, _rollback_quietly, _db_error, BEGIN IMMEDIATE/COMMIT/ROLLBACK, write_lock for mutations.
  </action>
  <verify>
    Run `uv run python -c "from gsd_review_broker.tools import accept_counter_patch, reject_counter_patch; print('OK')"` -- new tools importable.
    Run `uv run pytest tools/gsd-review-broker/tests/ -v --tb=short` -- existing tests still pass.
  </verify>
  <done>
    submit_verdict accepts optional counter_patch (validated via git apply --check, stored as pending). accept_counter_patch re-validates and replaces active diff. reject_counter_patch clears counter-patch columns. list_reviews sorts by priority. get_review_status supports optional notification wait. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Counter-patch lifecycle, priority sort, and notification polling tests</name>
  <files>
    tools/gsd-review-broker/tests/test_counter_patch.py
  </files>
  <action>
    Create test_counter_patch.py following the project's existing test patterns. Mock `validate_diff` where needed (same pattern as test_proposals.py -- patch "gsd_review_broker.tools.validate_diff").

    Create helpers:
    - `_create_review(ctx, **overrides)` -- creates a review with defaults (intent, agent_type="gsd-executor", agent_role="proposer", phase="01"), returns result dict.
    - `_create_and_claim(ctx, **overrides)` -- creates + claims, returns review_id.
    - `_create_claim_and_request_changes(ctx, counter_patch=None, **overrides)` -- creates, claims, submits request_changes verdict with optional counter_patch, returns review_id.

    **Test class: TestCounterPatchSubmission**
    - test_counter_patch_on_request_changes: Mock validate_diff returning (True, ""). Submit verdict "request_changes" with counter_patch="--- a/f\n+++ b/f\n..." and reason="use this instead". Assert response has has_counter_patch=True. Query DB to verify counter_patch, counter_patch_status='pending', counter_patch_affected_files are set.
    - test_counter_patch_on_comment: Same pattern with verdict="comment". Should succeed.
    - test_counter_patch_on_approve_rejected: Submit verdict "approved" with counter_patch. Assert error about counter-patches only allowed with request_changes or comment.
    - test_counter_patch_validation_failure: Mock validate_diff returning (False, "patch does not apply"). Submit verdict with counter_patch. Assert error about validation failure.
    - test_verdict_without_counter_patch_unchanged: Standard request_changes without counter_patch works as before. No counter_patch columns set.

    **Test class: TestAcceptCounterPatch**
    - test_accept_replaces_active_diff: Set up review with pending counter-patch. Mock validate_diff (True, ""). Call accept_counter_patch. Assert counter_patch_status='accepted'. Query DB: diff should now equal the counter-patch content, affected_files updated, counter_patch column cleared.
    - test_accept_with_stale_diff: Set up review with pending counter-patch. Mock validate_diff (False, "patch does not apply"). Call accept_counter_patch. Assert error about counter-patch no longer applying. Verify review state unchanged (counter_patch still present, status unchanged).
    - test_accept_no_pending_counter_patch: Call accept on review with no counter-patch. Assert error "No pending counter-patch".
    - test_accept_fires_notification: Use asyncio task waiting on notification bus. Accept counter-patch. Assert waiter was signaled.

    **Test class: TestRejectCounterPatch**
    - test_reject_clears_counter_patch: Set up review with pending counter-patch. Call reject_counter_patch. Assert counter_patch_status='rejected'. Query DB: counter_patch and counter_patch_affected_files are NULL.
    - test_reject_no_pending_counter_patch: Call reject on review with no counter-patch. Assert error.

    **Test class: TestRevisionClearsCounterPatch**
    - test_revision_clears_pending_counter_patch: Set up review with pending counter-patch (via submit_verdict). Then revise via create_review(review_id=...). Query DB: counter_patch columns are all NULL, current_round incremented.

    **Test class: TestPrioritySort**
    - test_list_reviews_sorted_by_priority: Create 3 reviews with different agent_types (gsd-executor for normal, gsd-planner for critical, gsd-verifier with phase containing "verify" for low). Call list_reviews(status="pending"). Assert order: critical first, then normal, then low.
    - test_same_priority_sorted_by_created_at: Create 2 reviews with same agent_type (both normal). Assert they appear in created_at order.
    - test_priority_included_in_response: list_reviews response dicts include "priority" key.

    **Test class: TestNotificationPolling**
    - test_get_review_status_wait_returns_on_signal: Create review. Start asyncio task calling get_review_status(review_id=..., wait=True). Fire notification from another task. Assert status returned (not timed out). Check that wait=True did not error.
    - test_get_review_status_wait_timeout: Create review. Call get_review_status(review_id=..., wait=True) but with no notification fired. Should return after ~25s timeout. For test speed, temporarily patch NotificationBus.wait_for_change timeout or use a shorter timeout. Actually, the tool uses 25s hardcoded. Better approach: just test wait=False works as before (immediate return), and test that wait=True with a signal works (fire notification immediately after starting the wait). Skip the 25s timeout test to keep tests fast.
    - test_get_review_status_default_no_wait: Call without wait param. Returns immediately (same as current behavior). Verify response includes priority and current_round fields.

    For all counter-patch tests, mock validate_diff to control validation outcomes.
  </action>
  <verify>
    Run `uv run pytest tools/gsd-review-broker/tests/test_counter_patch.py -v` -- all tests pass.
    Run `uv run pytest tools/gsd-review-broker/tests/ -v` -- full test suite passes with zero regressions.
  </verify>
  <done>
    Counter-patch lifecycle fully tested: submission with verdict, validation gating, accept (with re-validation and stale detection), reject, revision clearing. Priority sort verified in list_reviews. Notification-enhanced polling verified. All tests pass including the full existing suite.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tools/gsd-review-broker/tests/ -v` -- entire test suite passes (all Phase 1, 2, and 3 tests)
2. Counter-patch flow verified: submit_verdict with counter_patch -> accept_counter_patch (replaces active diff) or reject_counter_patch (clears)
3. list_reviews returns reviews sorted by priority (critical > normal > low)
4. get_review_status with wait=True blocks until notification or timeout
5. Revision clears pending counter-patch and increments round
</verification>

<success_criteria>
- submit_verdict accepts optional counter_patch parameter (validated, stored as pending)
- Counter-patches restricted to request_changes and comment verdicts only
- accept_counter_patch re-validates diff before replacing (stale diff returns error without state change)
- reject_counter_patch clears counter-patch columns
- list_reviews sorts by priority (critical first) then created_at
- get_review_status supports wait parameter for notification-driven polling
- get_review_status response includes priority and current_round
- All Phase 3 tests pass, all existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-discussion-and-patches/03-02-SUMMARY.md`
</output>
