---
phase: 01-core-broker-server
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - tools/gsd-review-broker/src/gsd_review_broker/tools.py
  - tools/gsd-review-broker/tests/test_state_machine.py
  - tools/gsd-review-broker/tests/test_tools.py
autonomous: true

must_haves:
  truths:
    - "Proposer can create a review with intent and agent identity via create_review tool and receives a review_id"
    - "Reviewer can list pending reviews via list_reviews tool"
    - "Reviewer can claim a pending review via claim_review tool, transitioning it to claimed status"
    - "Reviewer can submit a verdict (approved or changes_requested) via submit_verdict tool with optional reason"
    - "Proposer can close an approved or changes_requested review via close_review tool"
    - "Invalid state transitions are rejected with clear error messages"
  artifacts:
    - path: "tools/gsd-review-broker/src/gsd_review_broker/tools.py"
      provides: "5 MCP tool handlers: create_review, list_reviews, claim_review, submit_verdict, close_review"
      min_lines: 120
    - path: "tools/gsd-review-broker/tests/test_state_machine.py"
      provides: "State machine transition tests covering valid and invalid paths"
      min_lines: 40
    - path: "tools/gsd-review-broker/tests/test_tools.py"
      provides: "Integration tests for tool handlers using in-memory SQLite"
      min_lines: 80
  key_links:
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py"
      to: "tools/gsd-review-broker/src/gsd_review_broker/server.py"
      via: "@mcp.tool decorator registers handlers with FastMCP app"
      pattern: "@mcp\\.tool"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py"
      to: "tools/gsd-review-broker/src/gsd_review_broker/db.py"
      via: "ctx.lifespan_context provides AppContext with db connection"
      pattern: "ctx\\.lifespan_context"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py"
      to: "tools/gsd-review-broker/src/gsd_review_broker/state_machine.py"
      via: "validate_transition called before every status change"
      pattern: "validate_transition"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/tools.py"
      to: "SQLite reviews table"
      via: "BEGIN IMMEDIATE transactions for all writes"
      pattern: "BEGIN IMMEDIATE"
---

<objective>
Implement the 5 core MCP tool handlers that drive the review lifecycle (create, list, claim, verdict, close) plus comprehensive tests for both the state machine and tool integration.

Purpose: These tools are the API surface that proposer and reviewer agents use. Without them, the server is an empty shell. This plan delivers the full propose/claim/verdict/close lifecycle per PROTO-01 and PROTO-04.
Output: Working MCP tools registered on the server. A complete test suite proving the state machine rejects invalid transitions and tools correctly manipulate database state through the full lifecycle.
</objective>

<execution_context>
@C:\Users\Jacar\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Jacar\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-broker-server/01-RESEARCH.md
@.planning/phases/01-core-broker-server/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 5 MCP tool handlers for review lifecycle</name>
  <files>
    tools/gsd-review-broker/src/gsd_review_broker/tools.py
  </files>
  <action>
    Replace the placeholder tools.py with full implementations of the 5 Phase 1 tools. Each tool uses `@mcp.tool` decorator (no parentheses), accepts typed parameters, accesses the database via `ctx.lifespan_context`, and uses `BEGIN IMMEDIATE` for all writes.

    Import at top of file:
    - `mcp` from `gsd_review_broker.server`
    - `Context` from `fastmcp`
    - `AppContext` from `gsd_review_broker.db`
    - `ReviewStatus` from `gsd_review_broker.models`
    - `validate_transition` from `gsd_review_broker.state_machine`
    - `uuid` from stdlib

    **Tool 1: create_review**
    - Parameters: intent (str), agent_type (str), agent_role (str), phase (str), plan (str | None = None), task (str | None = None), ctx: Context = None
    - Generates UUID4 review_id
    - Executes `BEGIN IMMEDIATE`, INSERTs into reviews table with status="pending", all agent identity fields, created_at and updated_at as datetime('now')
    - COMMITs on success, ROLLBACKs on failure
    - Returns dict: {"review_id": review_id, "status": "pending"}
    - Docstring: "Create a new review for a proposed change. Returns review_id and initial status."

    **Tool 2: list_reviews**
    - Parameters: status (str | None = None), ctx: Context = None
    - If status provided, SELECT WHERE status = ?; otherwise SELECT all
    - Returns dict: {"reviews": [...list of review dicts with id, status, intent, agent_type, phase, created_at...]}
    - Docstring: "List reviews, optionally filtered by status. Use status='pending' to find reviews awaiting a reviewer."

    **Tool 3: claim_review**
    - Parameters: review_id (str), reviewer_id (str), ctx: Context = None
    - Fetches current review status
    - Calls `validate_transition(current_status, ReviewStatus.CLAIMED)` -- if invalid, return {"error": "..."}
    - Executes `BEGIN IMMEDIATE`, UPDATEs status to "claimed", sets claimed_by = reviewer_id, updates updated_at
    - Returns dict: {"review_id": review_id, "status": "claimed", "claimed_by": reviewer_id}
    - Docstring: "Claim a pending review for evaluation. Only pending reviews can be claimed."

    **Tool 4: submit_verdict**
    - Parameters: review_id (str), verdict (str), reason (str | None = None), ctx: Context = None
    - Validates verdict is one of: "approved", "changes_requested" (reject others with error)
    - Fetches current status
    - Maps verdict string to ReviewStatus enum value
    - Calls `validate_transition(current_status, target_status)` -- if invalid, return {"error": "..."}
    - Executes `BEGIN IMMEDIATE`, UPDATEs status and verdict_reason, updates updated_at
    - Returns dict: {"review_id": review_id, "status": verdict, "verdict_reason": reason}
    - Docstring: "Submit a verdict on a claimed review. Verdict must be 'approved' or 'changes_requested'."

    **Tool 5: close_review**
    - Parameters: review_id (str), ctx: Context = None
    - Fetches current status
    - Calls `validate_transition(current_status, ReviewStatus.CLOSED)` -- if invalid, return {"error": "..."}
    - Executes `BEGIN IMMEDIATE`, UPDATEs status to "closed", updates updated_at
    - Returns dict: {"review_id": review_id, "status": "closed"}
    - Docstring: "Close a review that has reached a terminal verdict (approved or changes_requested)."

    CRITICAL PATTERNS from research:
    - Every write uses `BEGIN IMMEDIATE` / `COMMIT` / `ROLLBACK` (research Pattern 3). Never bare INSERT/UPDATE.
    - `ctx: Context = None` -- Context is auto-injected by FastMCP, hidden from MCP schema.
    - Access db via `app: AppContext = ctx.lifespan_context` then `app.db`.
    - Return dicts (not Pydantic models) -- FastMCP serializes dicts directly.
    - On validation errors, return {"error": "message"} instead of raising (friendlier for AI agents).
    - Tool docstrings become the tool description visible to AI agents -- make them actionable.
    - For fetching review by ID, use `async with app.db.execute(...) as cursor: row = await cursor.fetchone()`. Check for None (review not found).
  </action>
  <verify>
    Run from `tools/gsd-review-broker/`:
    - `uv run python -c "from gsd_review_broker.tools import *; print('Tools imported')"` succeeds
    - `uv run gsd-review-broker` starts without import errors (Ctrl+C to stop)
    - `uv run ruff check src/` passes with no errors
  </verify>
  <done>
    5 MCP tools implemented and registered on the FastMCP server. Each tool handles database transactions with BEGIN IMMEDIATE. Error cases return {"error": "..."} dicts. Server starts with all tools registered.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for state machine and tool lifecycle integration</name>
  <files>
    tools/gsd-review-broker/tests/test_state_machine.py
    tools/gsd-review-broker/tests/test_tools.py
  </files>
  <action>
    Create comprehensive tests covering both the state machine logic and the full tool lifecycle.

    **test_state_machine.py** -- Unit tests for state_machine.py:
    - `test_valid_transitions_from_pending`: pending -> claimed succeeds
    - `test_valid_transitions_from_claimed`: claimed -> approved, claimed -> changes_requested, claimed -> in_review all succeed
    - `test_valid_transitions_from_approved`: approved -> closed succeeds
    - `test_valid_transitions_from_changes_requested`: changes_requested -> closed, changes_requested -> pending succeed
    - `test_invalid_transition_pending_to_approved`: pending -> approved raises ValueError
    - `test_invalid_transition_closed_to_anything`: closed -> any state raises ValueError
    - `test_invalid_transition_pending_to_closed`: pending -> closed raises ValueError
    - `test_all_states_have_transition_entry`: every ReviewStatus value is a key in VALID_TRANSITIONS

    Import: ReviewStatus from models, validate_transition and VALID_TRANSITIONS from state_machine.

    **test_tools.py** -- Integration tests using in-memory SQLite fixture from conftest.py:

    These tests call the tool handler functions directly, passing a mock context that provides the db fixture as lifespan_context. Create a simple helper:

    ```python
    from dataclasses import dataclass
    from gsd_review_broker.db import AppContext

    @dataclass
    class MockContext:
        lifespan_context: AppContext
    ```

    Then for each test, create `ctx = MockContext(lifespan_context=AppContext(db=db))` using the `db` fixture.

    Import the tool functions from `gsd_review_broker.tools`. Since they are decorated with `@mcp.tool`, you need to call the underlying function. FastMCP's `@mcp.tool` wraps the function -- call the function directly (it should still work as a regular async function when called directly with all args including ctx).

    NOTE: If `@mcp.tool` wrapping prevents direct calls, an alternative approach is to extract the core logic into helper functions that tools.py calls, and test those helpers. But try direct calls first.

    Tests:
    - `test_create_review`: Call create_review with valid args, verify returns review_id and status "pending", verify row exists in DB
    - `test_create_review_generates_unique_ids`: Create two reviews, verify different review_ids
    - `test_list_reviews_empty`: list_reviews on empty DB returns {"reviews": []}
    - `test_list_reviews_with_filter`: Create 2 reviews, claim one. list_reviews(status="pending") returns only the unclaimed one
    - `test_claim_review_success`: Create review, claim it, verify status changes to "claimed" and claimed_by is set
    - `test_claim_review_already_claimed`: Create and claim a review, try to claim again, verify error returned
    - `test_submit_verdict_approved`: Create, claim, submit verdict "approved", verify status
    - `test_submit_verdict_changes_requested`: Create, claim, submit verdict "changes_requested", verify status
    - `test_submit_verdict_invalid_verdict`: Submit verdict "maybe", verify error returned
    - `test_close_review_after_approval`: Full lifecycle: create -> claim -> approve -> close, verify final status "closed"
    - `test_close_review_from_pending_fails`: Create review, try to close immediately, verify error
    - `test_full_lifecycle`: End-to-end: create_review -> list_reviews (find it) -> claim_review -> submit_verdict("approved") -> close_review. Verify each step returns expected status.

    Run all tests with `uv run pytest tests/ -v`.
  </action>
  <verify>
    Run from `tools/gsd-review-broker/`:
    - `uv run pytest tests/test_state_machine.py -v` -- all tests pass
    - `uv run pytest tests/test_tools.py -v` -- all tests pass
    - `uv run pytest tests/ -v` -- full suite passes with 0 failures
    - `uv run ruff check tests/` -- no lint errors
  </verify>
  <done>
    State machine has 8+ tests covering all valid transitions and key invalid transitions. Tool integration has 12+ tests covering the full create -> claim -> verdict -> close lifecycle plus error cases. All tests pass. Full lifecycle proven end-to-end in test_full_lifecycle.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -v` passes all tests (20+ tests, 0 failures)
2. Server starts with `uv run gsd-review-broker`, shows 5 registered tools
3. `uv run ruff check src/ tests/` passes clean
4. State machine rejects invalid transitions (pending->approved, closed->anything)
5. Full lifecycle works: create -> list -> claim -> verdict -> close
</verification>

<success_criteria>
- 5 MCP tools registered and callable: create_review, list_reviews, claim_review, submit_verdict, close_review
- Every database write uses BEGIN IMMEDIATE / COMMIT / ROLLBACK pattern
- State machine validates transitions before every status change
- Error cases return {"error": "..."} instead of raising exceptions
- 20+ tests pass covering state machine + tool integration + full lifecycle
- Ruff lint clean on both src/ and tests/
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-broker-server/01-02-SUMMARY.md`
</output>
