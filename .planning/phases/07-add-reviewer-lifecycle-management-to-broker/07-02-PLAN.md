---
phase: 07-add-reviewer-lifecycle-management-to-broker
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - tools/gsd-review-broker/src/gsd_review_broker/pool.py
  - tools/gsd-review-broker/src/gsd_review_broker/platform_spawn.py
  - tools/gsd-review-broker/tests/test_pool.py
  - tools/gsd-review-broker/tests/test_platform_spawn.py
autonomous: true
requirements:
  - RLMC-01
  - RLMC-04

must_haves:
  truths:
    - "ReviewerPool can spawn a reviewer subprocess with shell-free argv"
    - "Platform detection correctly identifies Windows vs native for spawn strategy"
    - "Spawned reviewers get session-scoped IDs with unique suffix"
    - "Graceful drain marks reviewer, waits for current work, then terminates"
    - "Terminate kills process and records audit event"
    - "ReviewerPool tracks per-reviewer stats in memory and persists to DB"
    - "No subprocess invocation uses shell=True or constructs command strings"
  artifacts:
    - path: "tools/gsd-review-broker/src/gsd_review_broker/pool.py"
      provides: "ReviewerPool class with spawn, drain, terminate, shutdown_all"
      exports: ["ReviewerPool"]
      min_lines: 100
    - path: "tools/gsd-review-broker/src/gsd_review_broker/platform_spawn.py"
      provides: "Platform detection and argv builder"
      exports: ["detect_platform", "build_codex_argv"]
      min_lines: 30
    - path: "tools/gsd-review-broker/tests/test_pool.py"
      provides: "Tests for ReviewerPool spawn, drain, terminate lifecycle"
      min_lines: 80
    - path: "tools/gsd-review-broker/tests/test_platform_spawn.py"
      provides: "Tests for platform detection and argv construction"
      min_lines: 40
  key_links:
    - from: "tools/gsd-review-broker/src/gsd_review_broker/pool.py"
      to: "tools/gsd-review-broker/src/gsd_review_broker/platform_spawn.py"
      via: "build_codex_argv import"
      pattern: "from.*platform_spawn.*import.*build_codex_argv"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/pool.py"
      to: "tools/gsd-review-broker/src/gsd_review_broker/audit.py"
      via: "record_event for lifecycle events"
      pattern: "record_event.*reviewer_spawned|reviewer_drain_start|reviewer_terminated"
    - from: "tools/gsd-review-broker/src/gsd_review_broker/pool.py"
      to: "tools/gsd-review-broker/src/gsd_review_broker/config_schema.py"
      via: "SpawnConfig import"
      pattern: "from.*config_schema.*import.*SpawnConfig"
---

<objective>
ReviewerPool class and platform-aware subprocess spawning for Codex reviewer lifecycle.

Purpose: Build the core subprocess management layer that spawns Codex reviewers as shell-free subprocesses, tracks them in memory and SQLite, supports graceful drain on TTL/idle, and terminates cleanly. This is the engine that plans 03 (reclaim) and 04 (scaling/tools) depend on.
Output: pool.py (ReviewerPool), platform_spawn.py (argv builder), and comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-add-reviewer-lifecycle-management-to-broker/07-RESEARCH.md
@.planning/phases/07-add-reviewer-lifecycle-management-to-broker/07-01-SUMMARY.md
@tools/gsd-review-broker/src/gsd_review_broker/db.py
@tools/gsd-review-broker/src/gsd_review_broker/config_schema.py
@tools/gsd-review-broker/src/gsd_review_broker/audit.py
@tools/gsd-review-broker/tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Platform-aware argv builder</name>
  <files>
    tools/gsd-review-broker/src/gsd_review_broker/platform_spawn.py
    tools/gsd-review-broker/tests/test_platform_spawn.py
  </files>
  <action>
  **platform_spawn.py** -- Create new module with:

  1. `detect_platform() -> str`: Returns `"windows"` if `os.name == "nt"`, else `"native"`. Simple, matches existing codebase pattern (db.py line 193).

  2. `build_codex_argv(config: SpawnConfig) -> list[str]`: Builds shell-free argv list for codex exec.
     - Base args: `["codex", "exec", "--sandbox", "read-only", "--ephemeral", "--model", config.model, "-c", f"model_reasoning_effort={config.reasoning_effort}", "-C", config.workspace_path, "-"]`
     - The `-` at the end tells codex to read prompt from stdin.
     - On Windows (detect_platform() == "windows"): Prepend `["wsl", "-d", config.wsl_distro, "--"]` before codex args.
     - On native: Use codex args directly.
     - CRITICAL: No `shell=True`, no `bash -lc`, no string concatenation for commands. Every element is a separate list item.

  3. `load_prompt_template(template_path: str | Path, reviewer_id: str) -> str`: Load the reviewer_prompt.md template, substitute `{reviewer_id}` placeholder, return the prompt string. Use str.format() or str.replace() for simple substitution.

  **test_platform_spawn.py** -- Create test file with:
  - test_detect_platform_returns_string: verify returns "windows" or "native"
  - test_build_codex_argv_native: mock os.name to not "nt", verify argv starts with "codex" and contains "--sandbox", "read-only", "--ephemeral"
  - test_build_codex_argv_windows: mock os.name to "nt", verify argv starts with "wsl", "-d", distro, "--", "codex"
  - test_argv_is_list_of_strings: verify every element in returned argv is a str (no lists, no shell metacharacters expanding)
  - test_argv_contains_no_shell_metacharacters: construct SpawnConfig with workspace_path containing spaces and special chars, verify the path appears as a single argv element (not split by shell)
  - test_load_prompt_template: write a temp file with {reviewer_id} placeholder, load it, verify substitution
  - test_argv_dash_stdin_flag: verify "-" is the last element (stdin mode)
  </action>
  <verify>
  Run `cd C:/Projects/gsd-tandem/tools/gsd-review-broker && uv run pytest tests/test_platform_spawn.py -v` -- all tests pass. Verify no use of shell=True or string command assembly in platform_spawn.py.
  </verify>
  <done>
  Platform detection and shell-free argv builder work correctly on both Windows (WSL) and native platforms. Template loading substitutes reviewer_id. Tests confirm no shell metacharacter expansion.
  </done>
</task>

<task type="auto">
  <name>Task 2: ReviewerPool class with spawn, drain, and terminate</name>
  <files>
    tools/gsd-review-broker/src/gsd_review_broker/pool.py
    tools/gsd-review-broker/tests/test_pool.py
  </files>
  <action>
  **pool.py** -- Create new module with `ReviewerPool` dataclass/class:

  **Fields (in-memory state):**
  - session_token: str (generated via secrets.token_hex(4) at broker startup)
  - _counter: int = 0 (increments per spawn for display names)
  - _processes: dict[str, asyncio.subprocess.Process] (reviewer_id -> Process)
  - _draining: set[str] (reviewer IDs marked for drain)
  - _spawn_lock: asyncio.Lock (serializes scaling decisions to prevent concurrent over-spawn)
  - _last_spawn_time: float = 0.0 (monotonic timestamp)
  - config: SpawnConfig

  **Methods:**

  1. `async def spawn_reviewer(self, db: aiosqlite.Connection, write_lock: asyncio.Lock) -> dict`:
     - Rate-limit check: if `time.monotonic() - self._last_spawn_time < config.spawn_cooldown_seconds`, return error dict.
     - Pool cap check: if `len(active_reviewers) >= config.max_pool_size`, return error dict.
     - Increment _counter. Build display_name = f"codex-r{self._counter}". Build reviewer_id = f"{display_name}-{self.session_token}".
     - Build argv via `build_codex_argv(self.config)`.
     - Load prompt via `load_prompt_template(config.prompt_template_path, reviewer_id)`.
     - Spawn subprocess: `asyncio.create_subprocess_exec(*argv, stdin=PIPE, stdout=PIPE, stderr=PIPE)`.
     - Write prompt to stdin, close stdin (do NOT use communicate() since process is long-running).
     - Store process in `_processes[reviewer_id]`.
     - Update _last_spawn_time.
     - Insert row into `reviewers` table inside write_lock with BEGIN IMMEDIATE.
     - Record `reviewer_spawned` audit event with metadata {reviewer_id, display_name, pid}.
     - Return success dict with reviewer_id, display_name, pid.

  2. `async def drain_reviewer(self, reviewer_id: str, db: aiosqlite.Connection, write_lock: asyncio.Lock, reason: str = "manual") -> dict`:
     - Add reviewer_id to _draining set.
     - Update reviewers table status to 'draining' inside write_lock.
     - Record `reviewer_drain_start` audit event with metadata {reviewer_id, reason}.
     - If reviewer is not currently processing a review (check by querying reviews table for status='claimed' AND claimed_by=reviewer_id), call _terminate_reviewer immediately.
     - Return result dict.

  3. `async def _terminate_reviewer(self, reviewer_id: str, db: aiosqlite.Connection, write_lock: asyncio.Lock) -> None`:
     - Get process from _processes.
     - If process is still running (returncode is None): call terminate(), wait_for with 10s timeout, then kill() if timeout.
     - Remove from _processes and _draining.
     - Update reviewers table: status='terminated', terminated_at=datetime('now').
     - Record `reviewer_terminated` audit event with metadata {reviewer_id, exit_code, reviews_completed (from DB)}.

  4. `async def shutdown_all(self, db: aiosqlite.Connection, write_lock: asyncio.Lock) -> None`:
     - Drain and terminate all active reviewers. Used in lifespan cleanup.

  5. `@property def active_count(self) -> int`: Count of processes in _processes with returncode is None and not in _draining.

  6. `def is_draining(self, reviewer_id: str) -> bool`: Check if reviewer_id is in _draining set.

  7. `async def update_reviewer_stats(self, reviewer_id: str, db: aiosqlite.Connection, write_lock: asyncio.Lock, verdict: str, review_duration_seconds: float) -> None`:
     - Update reviewers table: increment reviews_completed, add to total_review_seconds, increment approvals or rejections based on verdict. Update last_active_at.

  **IMPORTANT constraints per user decisions:**
  - Never hold write_lock during subprocess spawn (spawn outside lock, record inside lock).
  - Use asyncio.create_subprocess_exec (not subprocess.Popen).
  - All DB operations use BEGIN IMMEDIATE / COMMIT / ROLLBACK pattern.

  **test_pool.py** -- Create test file. Since subprocess spawning needs mocking (we don't have codex in test env):
  - Mock `asyncio.create_subprocess_exec` to return a mock Process.
  - Mock `build_codex_argv` and `load_prompt_template`.
  - test_spawn_reviewer_creates_process: verify process stored in _processes, DB row inserted.
  - test_spawn_reviewer_rate_limited: set _last_spawn_time to now, verify error returned.
  - test_spawn_reviewer_pool_cap: fill pool to max, verify error returned.
  - test_spawn_reviewer_ids_contain_session_token: verify reviewer_id format is "codex-rN-{session_token}".
  - test_drain_reviewer_marks_draining: verify _draining set updated and DB status updated.
  - test_terminate_reviewer_kills_process: verify process.terminate() called, removed from _processes.
  - test_shutdown_all: spawn 2 mock reviewers, shutdown_all, verify both terminated.
  - test_spawn_records_audit_event: verify reviewer_spawned event in audit_events table.
  - test_terminate_records_audit_event: verify reviewer_terminated event in audit_events table.
  - test_active_count: spawn 2, drain 1, verify active_count is 1.
  - test_spawn_no_shell_true: verify the mock was called without shell=True argument.

  Use the existing conftest.py pattern (MockContext, in-memory SQLite). Create a helper fixture that provides a ReviewerPool with mocked subprocess calls.
  </action>
  <verify>
  Run `cd C:/Projects/gsd-tandem/tools/gsd-review-broker && uv run pytest tests/test_pool.py tests/test_platform_spawn.py -v` -- all tests pass. Verify pool.py has no shell=True usage. Verify write_lock is NOT held during subprocess spawn.
  </verify>
  <done>
  ReviewerPool spawns, drains, and terminates Codex reviewer subprocesses. All operations are shell-free, use asyncio.create_subprocess_exec, and record audit events. Per-reviewer stats tracked. Tests verify lifecycle with mocked subprocesses.
  </done>
</task>

</tasks>

<verification>
- `uv run pytest tests/ -v` from tools/gsd-review-broker/ -- all existing + new tests pass
- pool.py does not contain "shell=True" or "bash -lc"
- platform_spawn.py returns list[str] argv with no command-string assembly
- ReviewerPool.spawn_reviewer enforces rate limit and pool cap
- Reviewer IDs follow "codex-rN-{session_token}" pattern
- Audit events recorded for spawn, drain_start, terminated
</verification>

<success_criteria>
ReviewerPool can spawn, drain, and terminate reviewer subprocesses with full audit trail. Platform-aware argv builder produces correct commands for Windows (WSL) and native platforms. No subprocess uses shell=True.
</success_criteria>

<output>
After completion, create `.planning/phases/07-add-reviewer-lifecycle-management-to-broker/07-02-SUMMARY.md`
</output>
